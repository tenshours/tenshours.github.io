---
layout: post
title: "Java锁"
date: 2019-4-10
tags: lock
---

#### 锁

锁必须作用锁对象（引用类型），不能作用于基本类型。

#### 公平/非公平锁

公平锁是按照申请锁的顺序来获取的。非公平锁是有线程去抢占锁。

~~~java
//通过参数设置是否是公平锁
java.util.concurrent.locks.ReentrantLock#ReentrantLock(boolean)
~~~

#### 自旋锁

唤醒/阻塞线程，需要从用户态切换到核心态，状态的转换比较花费时间，所以，在线程不多的情况下，让线程自旋，等到可以获取资源的时候。自旋只是避免了线程的切换，但是线程一直在循环会占用CPU。默认情况自旋的次数是10，-XX:PreBlockSpin。如果10次之后还获取不到锁，就会使用重量级锁。JDK6之后，使用了自适应自旋锁。根据之前执行相同对象获取锁的情况来判断本次自旋的次数。

#### 消除锁

对一些代码进行同步，但是JVM发现，同步的的代码中没有使用共享数据。编译之后，class文件中就不会有关于锁的代码。

#### 粗化锁

当对一个对象频繁的加锁/释放锁，会消耗更多的性能。JVM发现有这种情况发生，会将锁作用的范围阔大。比如原来自作用于几行代码，粗化锁之后，会作用于整个方法。

#### 可重入锁

同一个线程，锁的是同一资源的时候，外层方法获取了锁之后，调用内层方法依然能够获取到该锁。

#### 读写锁

~~~java
java.util.concurrent.locks.ReadWriteLock
~~~

#### synchronized使用的锁

1. 偏向锁（总是同一线程获得锁时）
2. 轻量级锁（自旋）
3. 重量级锁（按顺序执行）

按照顺序条件不满足，最终会使用重量级锁。



reference：https://blog.csdn.net/u013256816/article/details/51204385



